---
title: 数据库锁和超时问题解决方案
date: 2026-01-22 10:23:48
tags: [后端开发, Django]
categories: [后端开发]
description: 数据库锁和超时问题解决方案
---
# 数据库锁和超时问题解决方案

## 问题背景

在生产环境中，我们遇到了两个接口频繁超时的问题：
- `get_receipt_number/` - 获取收货单号接口
- `get_purchase_number/` - 获取采购订单号接口

**典型症状**：
- 长时间无请求后（如几小时），首次请求容易出现超时
- 正常请求后，接口响应正常
- 高并发场景下，接口响应变慢甚至超时

## 问题分析

### 1. 数据库行级锁竞争（主要原因）

这两个接口都使用了数据库行级锁来保证并发安全：

```python
with transaction.atomic():
    counter, created = ReceiptNumberCounter.objects.select_for_update().get_or_create(
        year=current_year,
        month=current_month,
        defaults={'last_number': 10000}
    )
    counter.last_number -= 1
    counter.save()
```

**问题机制**：
1. `select_for_update()` 会对查询到的行加锁
2. 当多个请求同时访问时，第一个请求获得锁，其他请求必须等待
3. 如果等待时间超过数据库读取超时（30秒），请求就会超时失败

**为什么会出现锁等待**：
- 高并发场景：多个用户同时请求单号，都在等待同一行的锁
- 慢查询：如果某个请求执行时间较长，后续请求等待时间也会变长
- 事务未及时提交：如果事务持有锁的时间过长，会阻塞其他请求

### 2. 数据库连接失效

**问题机制**：
- Django 使用连接池管理数据库连接
- 长时间无请求后，MySQL 服务器可能关闭空闲连接
- 首次请求时，Django 尝试使用已失效的连接，需要重新建立连接
- 如果网络延迟或数据库响应慢，连接建立过程可能超时

**相关配置**：
```python
DATABASES = {
    "default": {
        "CONN_MAX_AGE": 300,  # 连接池中连接保留5分钟
        'OPTIONS': {
            'connect_timeout': 10,  # 连接超时10秒
            'read_timeout': 30,     # 读取超时30秒
        }
    }
}
```

### 3. get_or_create 与 select_for_update 的组合问题

**问题机制**：
- `get_or_create()` 在记录不存在时会尝试创建
- 但 `select_for_update()` 无法锁定不存在的行
- 在高并发场景下，多个请求可能同时尝试创建同一条记录
- 这会导致唯一约束冲突或锁等待时间变长

## 解决方案

### 方案一：优化锁机制，添加重试机制（推荐）

**核心思路**：
1. 将 `get_or_create()` 拆分为 `get()` 和 `create()`，避免组合问题
2. 添加重试机制，处理锁等待超时
3. 使用递增等待时间，避免所有请求同时重试

**实现代码**：

```python
from django.db import transaction
from django.db.utils import OperationalError
import time

class ReceiptNumberCounter(models.Model):
    # ... 现有字段定义 ...
    
    @staticmethod
    def get_next_receipt_number(max_retries=3):
        """
        获取下一个收货单号 (线程安全，带重试机制)
        
        参数:
            max_retries: 最大重试次数，默认3次
        """
        now = datetime.datetime.now()
        current_year = now.year
        current_month = now.month
        
        for attempt in range(max_retries):
            try:
                with transaction.atomic():
                    # 先尝试获取现有记录
                    try:
                        counter = ReceiptNumberCounter.objects.select_for_update(
                            nowait=False  # 允许等待锁释放
                        ).get(
                            year=current_year,
                            month=current_month
                        )
                    except ReceiptNumberCounter.DoesNotExist:
                        # 如果记录不存在，创建新记录
                        counter = ReceiptNumberCounter.objects.create(
                            year=current_year,
                            month=current_month,
                            last_number=10000
                        )
                    
                    # 更新计数器
                    counter.last_number -= 1
                    next_num = counter.last_number
                    counter.save()
                    
                    # 格式化并返回单号
                    receipt_number = f"SH{str(current_year)[-2:]}{current_month:02d}{next_num:04d}"
                    return receipt_number
                    
            except OperationalError as e:
                # 数据库操作错误（通常是锁等待超时）
                if attempt < max_retries - 1:
                    # 等待一小段时间后重试，使用递增等待时间
                    wait_time = 0.1 * (attempt + 1)  # 0.1秒, 0.2秒, 0.3秒...
                    time.sleep(wait_time)
                    continue
                else:
                    # 超过最大重试次数，抛出异常
                    raise Exception(f"获取收货单号失败：超过最大重试次数({max_retries})")
            except Exception as e:
                # 其他异常直接抛出
                raise
        
        raise Exception("获取收货单号失败：未知错误")


class PurchaseNumberCounter(models.Model):
    # ... 现有字段定义 ...
    
    @staticmethod
    def get_next_purchase_number(max_retries=3):
        """
        获取下一个采购订单号 (线程安全，带重试机制)
        """
        now = datetime.datetime.now()
        current_year = now.year
        current_month = now.month
        
        for attempt in range(max_retries):
            try:
                with transaction.atomic():
                    try:
                        counter = PurchaseNumberCounter.objects.select_for_update(
                            nowait=False
                        ).get(
                            year=current_year,
                            month=current_month
                        )
                    except PurchaseNumberCounter.DoesNotExist:
                        counter = PurchaseNumberCounter.objects.create(
                            year=current_year,
                            month=current_month,
                            last_number=0
                        )
                    
                    counter.last_number += 1
                    next_num = counter.last_number
                    counter.save()
                    
                    purchase_number = f"P{str(current_year)[-2:]}{current_month:02d}{next_num:05d}"
                    return purchase_number
                    
            except OperationalError as e:
                if attempt < max_retries - 1:
                    time.sleep(0.1 * (attempt + 1))
                    continue
                else:
                    raise Exception(f"获取采购订单号失败：超过最大重试次数({max_retries})")
            except Exception as e:
                raise
        
        raise Exception("获取采购订单号失败：未知错误")
```

**优势**：
- 解决了 `get_or_create()` 与 `select_for_update()` 的组合问题
- 通过重试机制提高了成功率
- 使用递增等待时间，避免所有请求同时重试造成"惊群效应"

### 方案二：设置数据库锁等待超时

**核心思路**：
在数据库层面设置锁等待超时，避免请求长时间等待。

**实现方式**：

在 `settings.py` 的数据库配置中添加：

```python
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.mysql",
        "NAME": 'srm_schedule',
        "USER": 'root',
        "PASSWORD": '123456',
        "HOST": '172.16.60.26',
        "PORT": 13306,
        "CONN_MAX_AGE": 300,  # 连接池保留5分钟
        'OPTIONS': {
            'charset': 'utf8mb4',
            # 设置时区和锁等待超时（MySQL 5.7+）
            'init_command': "SET time_zone = '+08:00', innodb_lock_wait_timeout = 5",
            'connect_timeout': 10,  # 连接超时10秒
            'read_timeout': 30,     # 读取超时30秒
            'write_timeout': 30,    # 写入超时30秒
        },
    }
}
```

**参数说明**：
- `innodb_lock_wait_timeout = 5`：InnoDB 锁等待超时为 5 秒
- 如果锁等待超过 5 秒，MySQL 会自动释放锁并返回错误
- 这样可以让应用层更快地处理错误并进行重试

### 方案三：优化视图层，添加连接检查和错误处理

**核心思路**：
在视图层确保数据库连接有效，并提供详细的错误信息便于排查。

**实现代码**：

```python
class ReceiptNumberView(APIView):
    """生成收货单号接口"""
    authentication_classes = []

    def get(self, request):
        try:
            # 确保数据库连接有效
            from django.db import connection
            connection.ensure_connection()
            
            receipt_number = ReceiptNumberCounter.get_next_receipt_number()
            return SuccessResponse(
                data={'receipt_number': receipt_number}, 
                msg="获取成功"
            )
        except Exception as e:
            import traceback
            error_detail = traceback.format_exc()
            # 记录详细错误信息，便于排查
            return ErrorResponse(
                data={
                    'error': str(e), 
                    'detail': error_detail
                }, 
                code=500, 
                msg="生成失败"
            )


class PurchaseNumberView(APIView):
    """采购订单号生成接口"""
    authentication_classes = []

    def get(self, request):
        try:
            from django.db import connection
            connection.ensure_connection()
            
            purchase_number = PurchaseNumberCounter.get_next_purchase_number()
            return SuccessResponse(
                data={'purchase_number': purchase_number}, 
                msg="获取成功"
            )
        except Exception as e:
            import traceback
            error_detail = traceback.format_exc()
            return ErrorResponse(
                data={
                    'error': str(e), 
                    'detail': error_detail
                }, 
                code=500, 
                msg="生成失败"
            )
```

**优势**：
- 在请求开始时确保连接有效，避免使用失效连接
- 提供详细的错误信息，便于问题排查
- 不影响业务逻辑，只是增强错误处理

## 超时配置详解

为了更好地理解各种超时配置的作用，我们详细说明一下：

### 1. CONN_MAX_AGE（连接池存活时间）

**作用**：控制连接在连接池中的最大存活时间

**原理**：
- Django 使用连接池复用数据库连接，避免频繁创建和销毁连接
- `CONN_MAX_AGE=300` 表示连接在池中最多保留 5 分钟
- 5 分钟后，Django 会关闭这个连接，下次请求时创建新连接

**为什么需要**：
- 减少连接建立的开销
- 避免连接被 MySQL 服务器关闭后仍在使用

### 2. connect_timeout（连接建立超时）

**作用**：建立 TCP 连接时的超时时间

**原理**：
- 当需要创建新连接时（首次连接或连接池中没有可用连接）
- 从发起连接到成功建立的时间限制
- 如果网络慢或数据库服务器无响应，超过这个时间就放弃

**典型场景**：
```
应用尝试连接 MySQL:172.16.60.26:13306
├─ 如果 10 秒内连接成功 → 继续
└─ 如果 10 秒内未连接成功 → 抛出超时异常
```

### 3. read_timeout（读取超时）

**作用**：执行 SQL 查询后，等待数据库返回结果的超时时间

**原理**：
- 查询已发送到数据库
- 等待数据库返回结果的时间限制
- 如果查询执行时间过长，超过这个时间就放弃

**典型场景**：
```
应用发送 SQL: SELECT * FROM large_table
├─ 数据库执行查询...
├─ 如果 30 秒内返回结果 → 成功
└─ 如果 30 秒内未返回 → 抛出读取超时异常
```

### 4. write_timeout（写入超时）

**作用**：执行 INSERT/UPDATE/DELETE 后，等待数据库确认的超时时间

**原理**：
- 写入操作已发送到数据库
- 等待数据库确认完成的时间限制
- 如果写入操作执行时间过长，超过这个时间就放弃

## 实施建议

### 优先级排序

1. **立即实施**：方案一（优化锁机制，添加重试）
   - 这是最直接有效的解决方案
   - 可以立即解决大部分超时问题
   - 实施风险低，不影响现有功能

2. **短期实施**：方案二（设置数据库锁等待超时）
   - 在数据库层面提供额外保护
   - 需要确认 MySQL 版本支持（5.7+）
   - 需要测试确保不影响其他功能

3. **长期优化**：方案三（优化视图层错误处理）
   - 提高问题排查效率
   - 改善用户体验
   - 可以作为持续改进的一部分

### 实施步骤

1. **备份现有代码**
   ```bash
   git commit -m "备份：优化数据库锁和超时处理前的代码"
   ```

2. **实施方案一**
   - 修改 `data_router/models.py` 中的两个方法
   - 添加重试机制和错误处理
   - 测试基本功能是否正常

3. **测试验证**
   - 单用户测试：确保基本功能正常
   - 并发测试：模拟多个用户同时请求
   - 压力测试：测试高并发场景下的表现

4. **监控观察**
   - 观察接口响应时间
   - 监控错误日志
   - 收集用户反馈

5. **逐步优化**
   - 根据监控数据调整重试次数和等待时间
   - 实施方案二和方案三
   - 持续优化和改进

## 监控和排查

### 关键指标

1. **接口响应时间**
   - 正常情况：< 100ms
   - 警告阈值：> 500ms
   - 错误阈值：> 30s（超时）

2. **错误率**
   - 正常情况：< 0.1%
   - 警告阈值：> 1%
   - 错误阈值：> 5%

3. **数据库连接数**
   - 监控活跃连接数
   - 监控连接池使用情况

### 排查工具

1. **Django Debug Toolbar**（开发环境）
   - 查看 SQL 查询时间
   - 查看数据库连接状态

2. **MySQL 慢查询日志**
   ```sql
   -- 查看当前锁等待情况
   SHOW ENGINE INNODB STATUS;
   
   -- 查看慢查询
   SHOW VARIABLES LIKE 'slow_query%';
   ```

3. **应用日志**
   - 记录详细的错误信息
   - 记录重试次数和等待时间

## 总结

数据库锁和超时问题是一个常见的生产环境问题，主要原因是：

1. **并发锁竞争**：多个请求同时访问同一行数据
2. **连接失效**：长时间无请求后连接失效
3. **配置不当**：超时时间设置不合理

通过以下措施可以有效解决：

1. **优化锁机制**：拆分 `get_or_create()`，添加重试机制
2. **设置合理超时**：在数据库和应用层都设置合理的超时时间
3. **增强错误处理**：提供详细的错误信息，便于排查

这些方案已经在生产环境中验证有效，可以显著提高接口的稳定性和响应速度。

首次启动预热数据库连接的方案:
```
# 代码添加到wsgi.py中

# 预热数据库连接（应用启动时执行一次）
# 验证数据库的首次连接 从 29s 降到了2s
def _warmup_database():
    """预热数据库连接，避免首次请求慢"""
    try:
        from django.db import connection
        # 执行一个简单的查询来建立连接
        with connection.cursor() as cursor:
            cursor.execute("SELECT 1")
    except Exception:
        # 如果预热失败，不影响应用启动
        pass

# 在应用加载后预热
_warmup_database()
```

## 参考资料

- [Django 数据库连接管理](https://docs.djangoproject.com/en/stable/topics/db/connections/)
- [MySQL InnoDB 锁机制](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)
- [Django select_for_update 文档](https://docs.djangoproject.com/en/stable/ref/models/querysets/#select-for-update)
